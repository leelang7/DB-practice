## 1. 집합 연산자 개념 - UNION/UNION ALL

`request_past`라는 신청(과거) 테이블과 `request_new`라는 신청(신규) 테이블에는 각 테이블에 구조에 맞도록 이름과 핸드폰 번호 정보가 공통으로 담겨 있습니다.

과거에 신청했던 이력과 신규로 신청했던 이력들에 대해 과거/신규를 구분하지 않고 이름과 핸드폰번호를 조회하려고 합니다.

두 개의 테이블에서 각각 **이름(name)** 과 **핸드폰 번호(number)** 를 조회하는 2개의 `SELECT` 쿼리 결과에 대해서 데이터를 연결하여 조회하되, **중복을 제거하지 않는 집합 연산자**를 이용한 쿼리와 **중복을 제거하는 집합 연산자**를 이용한 쿼리를 만들어 봅시다.

`request_past` 테이블과 `request_new` 테이블의 구조는 다음과 같습니다.

![image](https://cdn-api.elice.io/api-attachment/attachment/bb831313005f4904ad29363bb019161b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.29.27.png)

## 지시사항

1. `request_past`테이블과 `request_new` 테이블에서 각각 **이름(name)** 과 **번호(number)** 를 조회하는 `SELECT`문에 대해서 **중복을 제거하지 않는 집합 연산자**를 이용하여 데이터를 연결해보세요.
2. `request_past`테이블과 `request_new` 테이블에서 각각 **이름(name)** 과 **번호(number)** 를 조회하는 `SELECT`문에 대해서 **중복을 제거하는 집합 연산자**를 이용하여 데이터를 연결해보세요.

### Tips!

> - 1, 2번 결과에 대해 `ORDER BY` 를 이용하여 이름을 기준으로 오름차순 정렬을 해주세요.
> - 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 2. 집합 연산자 개념 - INTERSECT

`student`라는 학생 테이블에는 학생들의 정보가, `lecture_special`이라는 특별강의 테이블에는 강의에 대한 신청 정보가 담겨 있습니다.

학생 테이블에서 관리하는 학생들 중에서는 특별강의를 신청한 사람도 있고 아닌 사람도 있습니다.
***\*우리가 관리하고 있는 학생들 중에서 특별강의를 신청한 학생\****을 찾아봅시다.

두 개의 테이블에서 각각 ***\*이름(name)\**** 과 ***\*이메일(email)\**** 을 조회하는 2개의 SELECT 쿼리 결과에 대해서 공통으로 존재하는 데이터만 조회하는 쿼리를 ***\*집합 연산자\**** 로 만들어 봅시다.

`student` 테이블과 `lecture_special` 테이블의 구조는 다음과 같습니다.

![image](https://cdn-api.elice.io/api-attachment/attachment/9f950ead37304fbe95ab1d7e0c7cc4ca/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-10%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.07.19.png)

## 지시사항

1. `student`테이블을 확인하고, `SELECT`문을 이용해 **이름(name)** 과 **이메일(email)** 을 조회해 보세요.
2. `lecture_special`테이블을 확인하고, `SELECT`문을 이용해 **이름(name)** 와 **이메일(email)** 을 조회해 보세요.
3. 1번과 2번에서 조회된 결과에 대해서 **집합 연산자**를 이용해 공통으로 존재하는 데이터를 조회하세요.

### Tip!

> 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 3. 집합 연산자 개념 - EXCEPT

이번에는 ***\*특별강의는 수강하지만, 기본강의는 수강하지 않는 학생들\****의 정보를 조회해보려고 합니다.

두 개의 테이블에서 각각 ***\*학생 번호(student_number)\**** 와 ***\*학생 이름(student_name)\**** 을 조회하는 2개의 SELECT 쿼리 결과에 대해서, ***\*집합 연산자\**** 를 이용하여 `lecture_special` 테이블에는 존재하지만, `lecture_basic` 테이블에는 존재하지 않는 ***\*학생 번호(student_number)\**** 와 ***\*학생 이름(student_name)\**** 을 조회하는 쿼리를 작성해봅시다.

`lecture_basic` 테이블과 `lecture_special` 테이블의 구조는 서로 동일하며 다음과 같습니다.

![image](https://cdn-api.elice.io/api-attachment/attachment/732b333d249d43439be93973746ea906/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-07%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2010.40.13.png)

## 지시사항

1. `lecture_basic`테이블을 확인하고, `SELECT`문을 이용해 **학생 번호(student_number)** 와 **학생 이름(student_name)** 을 조회해 보세요.
2. `lecture_special`테이블을 확인하고, `SELECT`문을 이용해 **학생 번호(student_number)** 와 **학생 이름(student_name)** 을 조회해 보세요.
3. 1번과 2번에서 조회된 결과에 대해서 **집합 연산자**를 이용해 `lecture_special` 테이블에는 존재하지만, `lecture_basic` 테이블에는 존재하지 않는 데이터를 조회하세요.

### Tips!

> - 3번 결과에 대해 `ORDER BY` 를 이용하여 학생 번호를 기준으로 오름차순 정렬을 해주세요.
> - 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 4. 계층형 질의

`MEMBER` 테이블에는 멤버 ID, 관리자 ID가 담겨 있습니다.

각 멤버에 대해서 상위부터 몇 번째 관리자인지를 알아보고자 합니다. 즉, 최상위관리자는 0번째 관리자입니다.

**계층형 질의(WITH RECURSIVE)** 를 이용하여, `MEMBER` 테이블에 대해 계층형 결과를 출력하려고 합니다. 앞에서 학습한 내용을 토대로 **member_id, manager_id, lvl을 조회**하세요.

`MEMBER` 테이블의 구조는 다음과 같습니다.
![image](https://cdn-api.elice.io/api-attachment/attachment/d858625db4334caf8f0e0cb023bdb9c3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-19%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.24.07.png)

## 지시사항

**계층형 질의**의 `WITH RECURSIVE`문을 이용하여, `MEMBER`테이블에 대해 **member_id, manager_id, lvl을 조회**하세요.

### Tips!

> - lvl 값은 0부터 시작하도록 해주세요.
> - 결과에 대해 `ORDER BY` 를 이용하여 member_id 기준으로 오름차순, lvl 기준으로 오름차순 정렬을 해주세요.
> - 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 5. 멘토와 멘티, 정리해보자

엘리스 스쿨의 학생들은 멘토와 멘티 프로그램에 참여하고 있습니다.
멘토이면서 멘티인 학생도 있고, 멘토만 또는 멘티만 하는 학생도 있습니다.
(그림으로 그려보면 계층형이 될 것 같아요!)

어느 날, 엘리스 스쿨의 담당 선생님은 멘토와 멘티 정보가 담겨있는 `MEMBER` 테이블을 통해 누가 첫 번째 멘토인지, 누가 몇 번째 멘토인지, **계층적으로** 확인해보려고 합니다.

`MEMBER` 테이블의 정보는 다음과 같습니다.

![image](https://cdn-api.elice.io/api-attachment/attachment/c9dee2267caa4792a8ad34c047f5eb4d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-14%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201.52.18.png)

## 지시사항

`MEMBER` 테이블에 대해서 `WITH RECURSIVE` 절을 이용하여 데이터를 계층형으로 출력하는 쿼리를 작성해봅시다.

- 이때 출력하고자 하는 컬럼은, **mentee_id, mento_id, lvl** 이고, **가장 최상단에 있는 멘토는 lvl = 0 이고, 한 계층마다 1씩 증가하는 것** 으로 설정합시다.

### Tips!

> - 결과에 대해 `ORDER BY` 를 이용하여 lvl 오름차순, mentee_id 오름차순으로 정렬해주세요.
> - 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 6. FROM절 JOIN 형태 - INNER JOIN/USING

`STUDENT` 테이블에는 학생 번호와 학생 이름 정보가, `CLASS` 테이블에는 과목 번호와 과목 이름이, 그리고 `CLASS_REQUEST`테이블에는 신청 번호에 대한 학생 번호와 과목 번호 정보가 담겨 있습니다.

`CLASS_REQUEST` 테이블에는 학생 이름과 과목 이름 정보가 담겨있지 않고, 학생 번호와 과목 번호 정보가 담겨있습니다.
이에 대해서 `CLASS_REQUEST`의 각 데이터에 대해 과목 이름과 학생 이름 정보를 함께 출력해봅시다.

`CLASS_REQUEST` 테이블을 기준으로, 신청 번호에 따른 학생 이름과 과목 이름의 정보를 조회하려고 합니다. `JOIN` 절과 `USING` 절을 이용하여, `CLASS_REQUEST` 테이블에 `STUDENT` 테이블과 `CLASS` 테이블을 결합하여, **신청 번호(REQUEST_ID), 학생 이름(STUDENT_NAME), 과목 이름(CLASS_NAME)** 정보를 조회하는 쿼리를 작성해봅시다.

`CLASS_REQUEST`테이블과 `STUDENT`테이블, `CLASS`테이블의 구조는 다음과 같습니다.

![image](https://cdn-api.elice.io/api-attachment/attachment/6683bd8af729471298e6f0fb00c87617/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-12%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201.00.20.png)

## 지시사항

1. `CLASS_REQUEST`테이블에 대해 `STUDENT` 테이블을 `INNER JOIN`절 과 `USING`절을 이용하여 결합하고 **신청 번호(REQUEST_ID)와 학생 이름(STUDENT_NAME)** 을 조회하는 쿼리를 작성하세요.
2. `CLASS_REQUEST`테이블에 대해 `CLASS` 테이블을 `INNER JOIN`절 과 `USING`절을 이용하여 결합하고 **신청 번호(REQUEST_ID)와 과목 이름(CLASS_NAME)** 을 조회하는 쿼리를 작성하세요.
3. `CLASS_REQUEST`테이블에 대해 `STUDENT` 테이블과 `CLASS`테이블을 `INNER JOIN`절 과 `USING`절을 이용하여 결합하고 **신청 번호(REQUEST_ID)와 학생 이름(STUDENT_NAME), 과목 이름(CLASS_NAME)** 을 조회하는 쿼리를 작성하세요.

### Tips!

> - 1, 2, 3번 결과에 대해 `ORDER BY` 를 이용하여 신청 번호를 기준으로 오름차순 정렬을 해주세요.
> - 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 7. FROM절 JOIN 형태 - INNER JOIN/ON/WHERE

`REQUEST_HIST` 테이블에는 요청 ID, 요청 상태, 요청 멤버 ID 정보가 담겨 있으며 `MEMBER` 테이블에는 멤버 ID, 멤버 이름 정보가 담겨 있습니다.

위의 테이블을 이용하여, **어떤 멤버의 요청이 fail처리** 되었는지 확인해보려고 합니다. 이때 `REQUEST_HIST` 테이블에는 멤버 이름이 아닌, 요청 멤버 ID 정보가 담겨 있으므로 `MEMBER` 테이블과 `INNER JOIN`을 활용해 봅시다.

`REQUEST_HIST` 테이블에서 요청상태가 **fail** 인 정보에 대해서만 조회하되, `MEMBER` 테이블과 `INNER JOIN`을 활용하여 **요청 ID(request_id), 요청 상태(req_status), 멤버 이름(member_name)** 을 출력하는 쿼리를 작성해봅시다.

`REQUEST_HIST` 테이블과 `MEMBER` 테이블의 구조는 다음과 같습니다.

![image](https://cdn-api.elice.io/api-attachment/attachment/c751b02c43964cb695b01620f9fda4f7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-13%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.42.46.png)

## 지시사항

`REQUEST_HIST`테이블과 `MEMBER` 테이블에 대해서 **멤버 ID(req_member_id와 member_id)** 가 같은 데이터에 대해 `INNER JOIN`절과 `ON`절을 이용하고, **요청 상태(req_status) 가 fail**인 데이터에 대해서 **요청 ID(request_id), 요청 상태(req_status), 멤버 이름(member_name)** 을 조회하는 쿼리를 작성하세요.

### Tips!

> - 결과에 대해 `ORDER BY` 를 이용하여 요청 ID를 기준으로 오름차순 정렬을 해주세요.
> - 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 8. FROM절 JOIN 형태 - CROSS JOIN

`FIRST_NAME_T` 테이블과 `LAST_NAME_T` 테이블에는 각 테이블의 구조에 맞도록 id 값과 first_name 또는 last_name 정보가 담겨 있습니다.

`FIRST_NAME_T` 테이블의 데이터와 `LAST_NAME_T` 테이블의 데이터를 결합하면 가상의 이름 데이터 하나가 출력됩니다. 그럼 각 테이블의 모든 데이터를 이용하여 first_name과 last_name에 대한 모든 경우의 수를 구해봅시다.

가능한 이름의 조합에 대해 모든 경우의 수를 출력하기 위해 `CROSS JOIN`을 활용하려고 합니다.
`FIRST_NAME_T` 테이블과 `LAST_NAME_T` 테이블에 대해서 `CROSS JOIN`을 통해 결합하여 **first_name과 last_name을 출력하여** 가능한 모든 케이스를 조회하는 쿼리를 작성해봅시다.

`FIRST_NAME_T` 테이블과 `LAST_NAME_T` 테이블의 구조는 다음과 같습니다.

![image](https://cdn-api.elice.io/api-attachment/attachment/71d1508a1aa04d7c926b1ca746a8e703/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.09.34.png)

## 지시사항

`FIRST_NAME_T` 테이블과 `LAST_NAME_T` 테이블을 `CROSS JOIN`으로 결합하고 **first_name, last_name** 을 출력하는 쿼리를 작성하세요.

### Tips!

> - 결과에 대해 `ORDER BY` 를 이용하여 first_name를 기준으로 오름차순, last_name을 기준으로 오름차순 정렬을 해주세요.
> - 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 9. 뷰

`EMPLOYEE` 테이블에는 직원 ID, 부서 이름, 급여 정보가 담겨있습니다.

업무 상 부서이름이 ‘개발’인 직원들의 정보만 조회하는 경우가 빈번하여, 해당 직원들에 대한 뷰를 별도로 만들고자 합니다.

`EMPLOYEE` 테이블을 이용하여 **부서 이름이 ‘개발’인 직원들의 직원 ID, 급여 정보를 가진 뷰(EMPLOYEE_DEV)** 를 만드는 쿼리를 작성해봅시다.

`EMPLOYEE` 테이블의 구조는 아래와 같습니다.
![image](https://cdn-api.elice.io/api-attachment/attachment/fb7354487a22458bb67513b3145ff08a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-21%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201.34.21.png)

## 지시사항

1. `EMPLOYEE`테이블에서 **부서 이름(department_name)이 ‘개발’** 인 직원들의 **직원 ID(employee_id), 급여(salary)** 정보를 가지는 **EMPLOYEE_DEV 뷰(View)** 를 만드는 쿼리를 작성해봅시다.
2. 1번에서 만든 `EMPLOYEE_DEV` 뷰에 대하여 뷰의 모든 데이터를 출력하는 쿼리를 작성하세요.

### Tip!

> 데이터 조회 및 생성순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 10. 윈도우 함수 - 순위 함수

`GYM_MEMBER` 테이블에는 멤버 ID, 스쿼트 점수, 벤치 프레스 점수, 데드 리프트 점수 정보가 담겨 있습니다.

각 멤버 ID 별로 스쿼트 점수, 벤치 프레스 점수, 데드 리프트 점수의 합계를 구하고, 합계 점수를 기반으로 순위를 매겨 조회해 봅시다.

이때, 동일 점수는 같은 순위로 취급하지만 단건으로 취급하지 않는 `RANK`를 이용하여 쿼리를 작성해 봅시다.

`GYM_MEMBER` 테이블의 구조는 아래와 같습니다.
![image](https://cdn-api.elice.io/api-attachment/attachment/65cb1a31a3f64f13812754883928cf27/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-22%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%206.10.36.png)

## 지시사항

`GYM_MEMBER`테이블에서 스쿼트 점수, 벤치 프레스 점수, 데드 리프트 점수의 합계 점수에 대해 **동일 점수는 같은 순위로 취급하며, 단건으로 취급하지 않는** 순위 함수 `RANK`를 이용하여 순위를 매겨 조회해봅시다.
결과에서는 **멤버 ID(MEMBER_ID), 스쿼트 점수(SQUAT), 벤치 프레스 점수(BENCH_PRESS), 데드 리프트 점수(DEADLIFT), 합계 점수(WEIGHT_SUM), 순위(RANK) 총 6개의 컬럼을 조회**해야 하며, 이때 **순위는 `RANK`를 이용하고, 합계점수의 내림차순을 기준**으로 순위를 세웁니다.

### Tip!

> 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 11. 윈도우 함수 - 일반 집계 함수

`PRODUCT` 테이블에는 상품 ID, 상품 이름, 가격 정보가 담겨 있으며 `SELL` 테이블에는 판매 ID, 상품 ID, 수량, 판매자 이름 정보가 담겨 있습니다.

판매자가 상품별로 판매한 금액 합계를 구하고자 합니다. 이때 상품의 가격 정보는 `PRODUCT` 테이블에 있기때문에, `JOIN` 을 통해 상품의 가격을 가져오고, 가격과 판매 수량을 곱한 금액을 판매자의 이름, 상품 ID 별로 합계를 구해봅시다.

`SELL` 테이블과 `PRODUCT` 테이블을 상품 ID 기준으로 `INNER JOIN`을 실시하고, 판매자의 상품별 판매금액 합계를 조회하는 쿼리를 작성해 봅시다.

`PRODUCT` 테이블과 `SELL` 테이블의 구조는 아래와 같습니다.
![image](https://cdn-api.elice.io/api-attachment/attachment/a235307bce7c45ceaa1546ca4e2b9dcc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-22%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%206.46.56.png)

## 지시사항

1. `SELL` 테이블과 `PRODUCT` 테이블에 대해서 **상품 ID(PRODUCT_ID)** 를 기준으로 `INNER JOIN`을 실시하여 **판매 ID(SELL_ID), 판매자 이름(SELLER_NAME), 상품 이름(PRODUCT_NAME), 수량(QUANTITY)** 을 조회하는 쿼리를 작성해 봅시다.
2. 1번에서 작성한 쿼리를 기반으로, 집계 함수 `SUM`을 활용하여, **판매자 이름(SELLER_NAME), 상품 ID(PRODUCT_ID)** 별 **판매금액(PRICE \* QUANTITY)** 을 구할 수 있습니다.
   이를 활용하여 **판매 ID(SELL_ID), 판매자 이름(SELLER_NAME), 상품 이름(PRODUCT_NAME), 수량(QUANTITY), 판매금액(PRICE \* QUANTITY)** 총 5개 컬럼을 조회하는 쿼리를 작성해 봅시다.

### Tips!

> - 1번 결과에 대해 `ORDER BY` 를 이용하여 판매 ID를 기준으로 오름차순 정렬을 해주세요.
> - 2번 결과에 대해 `ORDER BY` 를 이용하여 판매 ID를 기준으로 오름차순 정렬을 해주세요.
> - 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 12. 그룹 내 비율 함수

`BUDGET_USE` 테이블에는 ID, 사용 코드, 비용 정보가 담겨있습니다.

예산 사용 테이블, `BUDGET_USE` 테이블에서 ***\*각 비용이 전체 비용 합계에서 차지하는 비율\****을 백분율(소수점 5번째 자리에서 반올림)로 조회해 봅시다.

`BUDGET_USE` 테이블의 구조는 아래와 같습니다.
![image](https://cdn-api.elice.io/api-attachment/attachment/dd22b94e81a04140b4df79aa713d0562/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-22%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%209.08.51.png)

## 지시사항

`BUDGET_USE` 테이블에서 **비용(EXPENSE)이 전체 비용 합계(SUM(EXPENSE))에서 차지하는 비율**을 구해 **ID, 사용 코드(USE_CODE), 비용(EXPENSE), 비율(RATIO)** 로 조회해 봅시다.
이때, 비율 값은 `ROUND` 함수를 이용하여 소수점 5번째 자리에서 반올림합니다.

### Tips!

> - ROUND() 함수는, ROUND(값, 값을 표현할 자리수)와 같이 사용할 수 있습니다.
> - 결과에 대해 `ORDER BY` 를 이용하여 ID를 기준으로 오름차순 정렬을 해주세요.
> - 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 13. B등급 누가 받을까

엘리스 스쿨에서는 시험 성적에 대해서 상위 30% 이내는 A등급을, 상위 70% 이내는 B등급을, 나머지는 C등급을 주려고 합니다.

우선 B등급을 받는 학생들의 번호를 출력하기 위해서 ID와 성적(SCORE) 정보가 담겨있는 `STUDENT` 테이블을 통해 **상위 30% 초과, 상위 70% 이내** 학생들의 ID를 확인해 봅시다.

`STUDENT` 테이블의 구조는 아래와 같습니다.
![image](https://cdn-api.elice.io/api-attachment/attachment/a227a059d7c1473b900fb2e5cca0c8a9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-23%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%209.15.54.png)

## 지시사항

1. `STUDENT` 테이블에서 그룹 내 비율 함수 `CUME_DIST()` 를 이용하여 ***\*학생들의 점수(SCORE) 내림차순을 기준으로 누적 백분율\**** 을 구해봅시다.
   해당 정보를 기반으로 ***\*ID, 점수(SCORE), 누적 백분율(CUME_DIST)\**** 을 조회하는 쿼리를 작성해 봅시다.
2. 1번에서 완성한 쿼리를 `FROM`절 ***\*서브쿼리\****로 활용하여 ***\*누적 백분율(CUME_DIST)이 상위 30% 초과(0.3 초과), 상위 70% 이내(0.7 이하)\**** 를 만족하는 학생들에 대해서 ***\*ID, 점수(SCORE), 누적 백분율(CUME_DIST)\**** 을 조회하는 쿼리를 작성해 봅시다.
3. - 이때, 서브쿼리에서는 ID를 기준으로 오름차순 정렬합니다.

### Tips!

> \- 1번 결과에 대해 `ORDER BY` 를 이용하여 ID를 기준으로 오름차순 정렬을 해주세요.
> \- 2번 결과에 대해 `ORDER BY` 를 이용하여 누적 백분율를 기준으로 오름차순 정렬을 해주세요.
> \- 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 14. 윈도우 함수 - 그룹 내 비율 함수(NTILE)

`STUDENT` 테이블에는 ID, 수학 점수, 물리 점수, 화학 점수 정보가 담겨있습니다.

학생들의 점수 총합을 기준으로 3개 반으로 나누어 구분지으려고 합니다.

학생들의 수학, 물리, 화학 점수의 총합을 기준으로 `NTILE`을 이용하여 3개의 그룹으로 나누어 조회하는 쿼리를 작성해 봅시다.

`STUDENT` 테이블의 구조는 아래와 같습니다.
![image](https://cdn-api.elice.io/api-attachment/attachment/3db77143783b4798a5f6d09985d15756/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2010.20.39.png)

## 지시사항

`STUDENT` 테이블에서 **수학 점수(MATH), 물리 점수(PHYSICS), 화학 점수(CHEMISTRY) 를 모두 합한 총합 점수(SCORE_SUM)** 를 구하고, `NTILE`을 이용하여 **총합 점수 내림차순 기준, 3개의 그룹** 으로 나누어 봅시다.
해당 값들을 통해 **ID, 수학 점수(MATH), 물리 점수(PHYSICS), 화학 점수(CHEMISTRY), 총합 점수(SCORE_SUM), 그룹 값(NTILE)** 을 조회하는 쿼리를 작성해 봅시다.

### Tips!

> - 결과에 대해 `ORDER BY` 를 이용하여 ID를 기준으로 오름차순 정렬을 해주세요.
> - 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.



## 15. 그룹 함수 - ROLL UP

이전 문제와 같이 `BOOK_HISTORY` 테이블에는 책 ID, 책 이름, 책 종류, 책 카테고리, 판매 개수 정보가 담겨있습니다.

이번에도 앞에서와 같이 **책 종류와 책 카테고리 묶음 별 판매개수를 알고자하는데, 책 종류 기준으로의 판매개수 정보와 전체 판매개수 정보**도 함께 알고자합니다.

책 판매 기록에서, 책 종류와 책 카테고리를 기준으로 `GROUP BY`를 이용해 그룹화하고 `ROLLUP`을 이용하여 총 판매 개수를 구하는 쿼리를 작성해 봅시다.

`BOOK_HISTORY` 테이블의 구조는 아래와 같습니다.
![image](https://cdn-api.elice.io/api-attachment/attachment/2a261ab7434441b28b6066941fcc578a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-04-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2010.53.48.png)

## 지시사항

`BOOK_HISTORY` 테이블에서 ***\*책 종류(KIND)와 책 카테고리(CATEGORY)\**** 를 기준으로 `GROUP BY`와 `SUM()`을 이용하여 ***\*책 종류(KIND), 책 카테고리(CATEGORY), 판매 개수 합(SUM)\**** 을 조회하는 쿼리를 작성해 봅시다.
이때, `ROLLUP`을 이용하여 ***\*그룹화하는 컬럼에 대한 부분적인 통계\****를 함께 조회해 봅시다.

### Tip!

- 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.
- 현재 실습 환경에 세팅된 `MariaDB`에서는 ROLLUP을 아래와 같은 문법으로 사용해야 합니다.

```
...
GROUP BY column1, column2 WITH ROLLUP;
```